\paragraph{Planning}

Planning  has been a subject of much research in artificial intelligence. Here, planning usually refers to generating a sequence of actions that enables an \textit{agent} to achieve a specific \textit{goal}~\cite{norvig}. This can be achieved by classical search-based problem solving  approaches or logical planning agents. Such planning tasks now play a significant role in a variety of demanding applications, ranging from controlling space vehicles and robots to playing the game of bridge~\cite{ghallab04}. Some common planning paradigms include: 
\be
\item[(a)] \textit{Classical planning:} This is used when the initial state is fully-observable and any action is deterministic. Classical Planning is most useful when the problem is not very complex and there's a well-founded model~\cite{strips,wooldridge95}. In case of complex domains like SE, classical planning is highly inefficient~\cite{ghallab04}; 
\item[(b)] \textit{Probabilistic planning:} Here the outcomes may be random and are partly controlled by the decision maker~\cite{Bel, altman99, guo2009}. These kinds of planning problems are usually solved using dynamic programming and reinforcement learning\cite{ghallab04}; 
\item[(c)] \textit{Preference-based planning:} This is an extension of the above planning schemes with a focus on producing plans that satisfy as many user-defined constraints (preferences) as possible~\cite{son06 , baier09}. 
\ee

Note that the existence of a model precludes the use of each of these planning approaches. This is a limitation of all these planning approaches since not every domain has a reliable model. 

There are at least two kinds of planning research in SE which are distinguishable by {\em what} is being changed. In {\em test-based planning}, some optimization is applied to reduce the number of tests required to achieve to a certain goal~\cite{tallam2006concept, yoo2012regression, blue2013interaction}. In {\em process-based planning} some search-based optimizer is applied to a software process model to infer high-level business plans about software projects. For example, Ruhe et al.'s work on next release planning in requirements engineering~\cite{ruhe2003quantitative, ruhe2010product}. This proposal is about {\em code-based planning} where the goal is to change a code base in order to improve that code in some way. More generally, in software engineering, the planning problem translates to proposing changes to software artifacts. Solving this has been undertaken via the use of some search-based software engineering techniques~\cite{Harman2009}, with algorithms such as SWAY, NSGA-II, etc.~\cite{Nair2016,deb00a}.

These search-based software engineering techniques require access to some trustworthy models that can be used to explore novel solutions. In some software engineering domains there is ready access to such models which can offer assessment of newly generated plans. Examples of such domains within software engineering include automated program repair~\cite{Weimer2009, LeGoues2015}, software product line management~\cite{sayyad13, henard15}, etc. However, not all domains come with ready-to-use models. For example, consider software defect prediction and all the intricate issues that may lead to defects in a product. A model that includes {\em all} those potential issues would be very large and complex. Further, even when there is an existing model, they can require constant  maintenance lest they become out-dated. In such domains, we seek alternate methods for planning that can be automatically updated with new data without a need for comprehensive models. One approach is to use data mining approaches to create a quasi-model of the domain and make of use observable states from this data to generate an estimation of the model. Our preferred tools in this proposal (CrossTREE) takes this approach by constructing decision trees on available data (discussed in \fig{tutorial}). 